import fs from "fs-extra";
import path from "path";
import chalk from "chalk";

export async function createBaseStructure(targetDir: string): Promise<void> {
    console.log(chalk.blue(`Creating base structure at: ${targetDir}`));

    // Create main directories
    const directories = [targetDir, path.join(targetDir, "types"), path.join(targetDir, "utils"), path.join(targetDir, "constants")];

    for (const dir of directories) {
        await fs.ensureDir(dir);
        console.log(chalk.green(`✓ Created directory: ${path.relative(process.cwd(), dir)}`));
    }

    // Create base types file
    await createTypesFile(targetDir);

    // Create separate enum files
    await createTokenSymbolFile(targetDir);
    await createWalletNameFile(targetDir);
    await createSystemNameFile(targetDir);

    // Create utility files
    await createUtilsFiles(targetDir);

    // Create constants file
    await createConstantsFile(targetDir);

    // Create universal icon component
    await createUniversalIconComponent(targetDir);

    // Create index exports
    await createIndexFiles(targetDir);
}

async function createTypesFile(targetDir: string): Promise<void> {
    const typesContent = `export type ComponentProps = {
  className?: string;
  size?: number;        // For square icons, applies to both width and height
  width?: number;       // Specific width (overrides size)
  height?: number;      // Specific height (overrides size)
  alt?: string;
};

export type IconUrls = {
  lightMode: string;
  darkMode: string;
};

// Import enums from separate files
export { TokenSymbol } from './TokenSymbol';
export { WalletName } from './WalletName';
export { SystemName } from './SystemName';
`;

    const typesFile = path.join(targetDir, "types", "index.ts");
    await fs.writeFile(typesFile, typesContent);
    console.log(chalk.green(`✓ Created types file: ${path.relative(process.cwd(), typesFile)}`));
}

async function createTokenSymbolFile(targetDir: string): Promise<void> {
    const tokenSymbolContent = `// Token symbols enum
export enum TokenSymbol {
  // Example: BTC = "BTC"
}
`;

    const tokenSymbolFile = path.join(targetDir, "types", "TokenSymbol.ts");
    await fs.writeFile(tokenSymbolFile, tokenSymbolContent);
    console.log(chalk.green(`✓ Created TokenSymbol file: ${path.relative(process.cwd(), tokenSymbolFile)}`));
}

async function createWalletNameFile(targetDir: string): Promise<void> {
    const walletNameContent = `// Wallet names enum
export enum WalletName {
  // Example: MetaMask = "MetaMask"
}
`;

    const walletNameFile = path.join(targetDir, "types", "WalletName.ts");
    await fs.writeFile(walletNameFile, walletNameContent);
    console.log(chalk.green(`✓ Created WalletName file: ${path.relative(process.cwd(), walletNameFile)}`));
}

async function createSystemNameFile(targetDir: string): Promise<void> {
    const systemNameContent = `// System names enum
export enum SystemName {
  // Example: Ethereum = "Ethereum"
}
`;

    const systemNameFile = path.join(targetDir, "types", "SystemName.ts");
    await fs.writeFile(systemNameFile, systemNameContent);
    console.log(chalk.green(`✓ Created SystemName file: ${path.relative(process.cwd(), systemNameFile)}`));
}

async function createUtilsFiles(targetDir: string): Promise<void> {
    const utilsContent = `// Utility functions for theme handling
export function getImageSrc(lightMode: string, darkMode: string, mode: "light" | "dark"): string {
  return mode === "dark" ? darkMode : lightMode;
}
`;

    const utilsFile = path.join(targetDir, "utils", "theme.ts");
    await fs.writeFile(utilsFile, utilsContent);
    console.log(chalk.green(`✓ Created utils file: ${path.relative(process.cwd(), utilsFile)}`));
}

async function createConstantsFile(targetDir: string): Promise<void> {
    const constantsContent = `// Image path constants - auto-generated by CLI
export type ImagePaths = {
  lightMode: string;
  darkMode: string;
};

// Firebase Hosting URLs
export const baseImgUrl = 'https://crypto-images-4545f.web.app/images';
export const baseImgUrlToken = (nameToken: string) => \`\${baseImgUrl}/token/\${nameToken}.png\`;
export const baseImgUrlSystem = (nameSystem: string) => \`\${baseImgUrl}/system/\${nameSystem}.png\`;
export const baseImgUrlWallet = (nameWallet: string) => \`\${baseImgUrl}/wallet/\${nameWallet}.png\`;

// Icon name mapping - auto-generated by CLI
export const iconMap: Record<string, ImagePaths> = {
  // Token icons will be added here
  
  // Wallet icons will be added here  
  
  // System icons will be added here
};

// Helper function to get icon paths by name
export function getIconPaths(name: string): ImagePaths | null {
  return iconMap[name] || null;
}
`;

    const constantsFile = path.join(targetDir, "constants", "imagePaths.ts");
    await fs.writeFile(constantsFile, constantsContent);
    console.log(chalk.green(`✓ Created constants file: ${path.relative(process.cwd(), constantsFile)}`));
}

async function createUniversalIconComponent(targetDir: string): Promise<void> {
    const componentContent = `"use client";
import Image, { ImageProps } from "next/image";
import { ComponentProps } from "./types";
import { getIconPaths } from "./constants/imagePaths";
import { useState } from "react";

export type CryptoIconProps = Omit<ComponentProps, 'alt'> & 
  Omit<ImageProps, 'src' | 'width' | 'height' | 'alt'> & {
  name: string;  // Tên icon (ví dụ: "BTC", "MetaMask", "Ethereum")
  mode?: "light" | "dark"; // Chế độ hiển thị (mặc định: "light")
  fallback?: React.ReactNode; // Component hiển thị khi không tìm thấy icon
  
  // Override Image props với types rõ ràng hơn
  width?: number;
  height?: number; 
  alt?: string;
  
  // Error handling
  onError?: (error: Error) => void;
  onLoadingComplete?: (result: { naturalWidth: number; naturalHeight: number }) => void;
  
  // Loading states
  placeholder?: "blur" | "empty" | undefined;
  blurDataURL?: string;
  
  // Custom loading component
  loadingComponent?: React.ReactNode;
  errorComponent?: React.ReactNode;
};

export function CryptoIcon({
  name,
  mode = "light",
  className = "",
  size = 24,
  width,
  height,
  alt,
  fallback,
  onError,
  onLoadingComplete,
  placeholder,
  blurDataURL,
  loadingComponent,
  errorComponent,
  ...imageProps
}: CryptoIconProps) {
  const [imageState, setImageState] = useState<'loading' | 'loaded' | 'error'>('loading');
  const [imageError, setImageError] = useState<Error | null>(null);
  
  const iconPaths = getIconPaths(name);
  
  // Nếu không tìm thấy icon trong map, hiển thị fallback hoặc text
  if (!iconPaths) {
    if (fallback) {
      return <>{fallback}</>;
    }
    
    // Hiển thị text với style giống như icon
    const finalWidth = width ?? size;
    const finalHeight = height ?? size;
    
    return (
      <div
        className={\`inline-flex items-center justify-center bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300 text-xs font-medium rounded \${className}\`}
        style={{ width: finalWidth, height: finalHeight }}
        title={alt || name}
      >
        {name.length > 4 ? name.substring(0, 4) : name}
      </div>
    );
  }
  
  const finalWidth = width ?? size;
  const finalHeight = height ?? size;
  const imageSrc = mode === "dark" ? iconPaths.darkMode : iconPaths.lightMode;
  
  // Handle image error
  const handleError = () => {
    const error = new Error(\`Failed to load image: \${imageSrc}\`);
    setImageError(error);
    setImageState('error');
    if (onError) {
      onError(error);
    }
  };
  
  // Handle loading complete
  const handleLoadingComplete = (result: { naturalWidth: number; naturalHeight: number }) => {
    setImageState('loaded');
    if (onLoadingComplete) {
      onLoadingComplete(result);
    }
  };
  
  // Show loading component while image is loading
  if (imageState === 'loading' && loadingComponent) {
    return <>{loadingComponent}</>;
  }
  
  // Show error component or fallback when image fails to load
  if (imageState === 'error') {
    if (errorComponent) {
      return <>{errorComponent}</>;
    }
    
    if (fallback) {
      return <>{fallback}</>;
    }
    
    // Default error fallback
    return (
      <div
        className={\`inline-flex items-center justify-center bg-red-100 dark:bg-red-900 text-red-600 dark:text-red-300 text-xs font-medium rounded border border-red-300 dark:border-red-700 \${className}\`}
        style={{ width: finalWidth, height: finalHeight }}
        title={\`Error loading \${alt || name}\`}
      >
        ❌
      </div>
    );
  }
  
  return (
    <Image
      src={imageSrc}
      alt={alt || name}
      width={finalWidth}
      height={finalHeight}
      className={\`transition-all duration-200 \${className}\`}
      onError={handleError}
      onLoadingComplete={handleLoadingComplete}
      placeholder={placeholder}
      blurDataURL={blurDataURL}
      {...imageProps}
    />
  );
}
`;

    const componentFile = path.join(targetDir, "CryptoIcon.tsx");
    await fs.writeFile(componentFile, componentContent);
    console.log(chalk.green(`✓ Created universal icon component: ${path.relative(process.cwd(), componentFile)}`));
}

async function createIndexFiles(targetDir: string): Promise<void> {
    const mainIndexContent = `export { CryptoIcon } from './CryptoIcon';
export * from './types';
export * from './constants/imagePaths';
`;

    const mainIndexFile = path.join(targetDir, "index.ts");
    await fs.writeFile(mainIndexFile, mainIndexContent);
    console.log(chalk.green(`✓ Created main index file: ${path.relative(process.cwd(), mainIndexFile)}`));
}
