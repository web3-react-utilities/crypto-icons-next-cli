import fs from "fs-extra";
import path from "path";
import chalk from "chalk";

export async function createBaseStructure(targetDir: string): Promise<void> {
    console.log(chalk.blue(`Creating base structure at: ${targetDir}`));

    // Create main directories
    const directories = [
        targetDir,
        path.join(targetDir, "tokens"),
        path.join(targetDir, "wallets"),
        path.join(targetDir, "systems"),
        path.join(targetDir, "types"),
        path.join(targetDir, "utils"),
        path.join(targetDir, "constants"),
    ];

    for (const dir of directories) {
        await fs.ensureDir(dir);
        console.log(chalk.green(`✓ Created directory: ${path.relative(process.cwd(), dir)}`));
    }

    // Create base types file
    await createTypesFile(targetDir);

    // Create separate enum files
    await createTokenSymbolFile(targetDir);
    await createWalletNameFile(targetDir);
    await createSystemNameFile(targetDir);

    // Create utility files
    await createUtilsFiles(targetDir);

    // Create constants file
    await createConstantsFile(targetDir);

    // Create universal icon component
    await createUniversalIconComponent(targetDir);

    // Create index exports
    await createIndexFiles(targetDir);
}

async function createTypesFile(targetDir: string): Promise<void> {
    const typesContent = `export type ComponentProps = {
  className?: string;
  size?: number;        // For square icons, applies to both width and height
  width?: number;       // Specific width (overrides size)
  height?: number;      // Specific height (overrides size)
  alt?: string;
};

export type IconUrls = {
  lightMode: string;
  darkMode: string;
};

// Import enums from separate files
export { TokenSymbol } from './TokenSymbol';
export { WalletName } from './WalletName';
export { SystemName } from './SystemName';
`;

    const typesFile = path.join(targetDir, "types", "index.ts");
    await fs.writeFile(typesFile, typesContent);
    console.log(chalk.green(`✓ Created types file: ${path.relative(process.cwd(), typesFile)}`));
}

async function createTokenSymbolFile(targetDir: string): Promise<void> {
    const tokenSymbolContent = `// Token symbols enum
export enum TokenSymbol {
  // Example: BTC = "BTC"
}
`;

    const tokenSymbolFile = path.join(targetDir, "types", "TokenSymbol.ts");
    await fs.writeFile(tokenSymbolFile, tokenSymbolContent);
    console.log(chalk.green(`✓ Created TokenSymbol file: ${path.relative(process.cwd(), tokenSymbolFile)}`));
}

async function createWalletNameFile(targetDir: string): Promise<void> {
    const walletNameContent = `// Wallet names enum
export enum WalletName {
  // Example: MetaMask = "MetaMask"
}
`;

    const walletNameFile = path.join(targetDir, "types", "WalletName.ts");
    await fs.writeFile(walletNameFile, walletNameContent);
    console.log(chalk.green(`✓ Created WalletName file: ${path.relative(process.cwd(), walletNameFile)}`));
}

async function createSystemNameFile(targetDir: string): Promise<void> {
    const systemNameContent = `// System names enum
export enum SystemName {
  // Example: Ethereum = "Ethereum"
}
`;

    const systemNameFile = path.join(targetDir, "types", "SystemName.ts");
    await fs.writeFile(systemNameFile, systemNameContent);
    console.log(chalk.green(`✓ Created SystemName file: ${path.relative(process.cwd(), systemNameFile)}`));
}

async function createUtilsFiles(targetDir: string): Promise<void> {
    const utilsContent = `import { useTheme } from "next-themes";

export function useIsDarkMode(): boolean {
  const { theme, systemTheme } = useTheme();
  return theme === 'dark' || (theme === 'system' && systemTheme === 'dark');
}

export function getImageSrc(lightMode: string, darkMode: string, isDark: boolean): string {
  return isDark ? darkMode : lightMode;
}
`;

    const utilsFile = path.join(targetDir, "utils", "theme.ts");
    await fs.writeFile(utilsFile, utilsContent);
    console.log(chalk.green(`✓ Created utils file: ${path.relative(process.cwd(), utilsFile)}`));
}

async function createConstantsFile(targetDir: string): Promise<void> {
    const constantsContent = `// Image path constants - auto-generated by CLI
export type ImagePaths = {
  lightMode: string;
  darkMode: string;
};

// Icon name mapping - auto-generated by CLI
export const iconMap: Record<string, ImagePaths> = {
  // Token icons will be added here
  // Example: "BTC": { lightMode: "...", darkMode: "..." },
  
  // Wallet icons will be added here  
  // Example: "MetaMask": { lightMode: "...", darkMode: "..." },
  
  // System icons will be added here
  // Example: "Ethereum": { lightMode: "...", darkMode: "..." },
};

// Helper function to get icon paths by name
export function getIconPaths(name: string): ImagePaths | null {
  return iconMap[name] || null;
}
`;

    const constantsFile = path.join(targetDir, "constants", "imagePaths.ts");
    await fs.writeFile(constantsFile, constantsContent);
    console.log(chalk.green(`✓ Created constants file: ${path.relative(process.cwd(), constantsFile)}`));
}

async function createUniversalIconComponent(targetDir: string): Promise<void> {
    const componentContent = `"use client";
import Image from "next/image";
import { useEffect, useState } from "react";
import { ComponentProps } from "./types";
import { getIconPaths } from "./constants/imagePaths";

export type CryptoIconProps = ComponentProps & {
  name: string;  // Tên icon (ví dụ: "BTC", "MetaMask", "Ethereum")
  fallback?: React.ReactNode; // Component hiển thị khi không tìm thấy icon
  darkModeClass?: string; // CSS class để detect dark mode (default: "dark")
};

export function CryptoIcon({
  name,
  className = "",
  size = 24,
  width,
  height,
  alt,
  fallback,
  darkModeClass = "dark"
}: CryptoIconProps) {
  const [isDark, setIsDark] = useState(false);
  
  useEffect(() => {
    // Check if dark mode class exists on document element
    const checkDarkMode = () => {
      const hasDarkClass = document.documentElement.classList.contains(darkModeClass) ||
                          document.body.classList.contains(darkModeClass);
      setIsDark(hasDarkClass);
    };
    
    // Initial check
    checkDarkMode();
    
    // Listen for class changes using MutationObserver
    const observer = new MutationObserver(checkDarkMode);
    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class']
    });
    observer.observe(document.body, {
      attributes: true,
      attributeFilter: ['class']
    });
    
    return () => observer.disconnect();
  }, [darkModeClass]);
  
  const iconPaths = getIconPaths(name);
  
  // Nếu không tìm thấy icon, hiển thị fallback hoặc text
  if (!iconPaths) {
    if (fallback) {
      return <>{fallback}</>;
    }
    
    // Hiển thị text với style giống như icon
    const finalWidth = width ?? size;
    const finalHeight = height ?? size;
    
    return (
      <div
        className={\`inline-flex items-center justify-center bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300 text-xs font-medium rounded \${className}\`}
        style={{ width: finalWidth, height: finalHeight }}
        title={alt || name}
      >
        {name.length > 4 ? name.substring(0, 4) : name}
      </div>
    );
  }
  
  const finalWidth = width ?? size;
  const finalHeight = height ?? size;
  const imageSrc = isDark ? iconPaths.darkMode : iconPaths.lightMode;
  
  return (
    <Image
      src={imageSrc}
      alt={alt || name}
      width={finalWidth}
      height={finalHeight}
      className={\`transition-all duration-200 \${className}\`}
      priority={false}
    />
  );
}
`;

    const componentFile = path.join(targetDir, "CryptoIcon.tsx");
    await fs.writeFile(componentFile, componentContent);
    console.log(chalk.green(`✓ Created universal icon component: ${path.relative(process.cwd(), componentFile)}`));
}

async function createIndexFiles(targetDir: string): Promise<void> {
    const indexFiles = [
        { path: path.join(targetDir, "tokens", "index.ts"), content: "// Token exports will be added here\n" },
        { path: path.join(targetDir, "wallets", "index.ts"), content: "// Wallet exports will be added here\n" },
        { path: path.join(targetDir, "systems", "index.ts"), content: "// System exports will be added here\n" },
        {
            path: path.join(targetDir, "index.ts"),
            content: `export { CryptoIcon } from './CryptoIcon';
export * from './tokens';
export * from './wallets';
export * from './systems';
export * from './types';
export * from './constants/imagePaths';
`,
        },
    ];

    for (const file of indexFiles) {
        await fs.writeFile(file.path, file.content);
        console.log(chalk.green(`✓ Created index file: ${path.relative(process.cwd(), file.path)}`));
    }
}
