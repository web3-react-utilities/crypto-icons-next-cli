import fs from "fs-extra";
import path from "path";
import chalk from "chalk";

export async function createBaseStructure(targetDir: string, framework: "next" | "vite" = "next"): Promise<void> {
    console.log(chalk.blue(`Creating base structure at: ${targetDir}`));

    const directories = [targetDir, path.join(targetDir, "types"), path.join(targetDir, "utils"), path.join(targetDir, "constants")];
    for (const dir of directories) {
        await fs.ensureDir(dir);
        console.log(chalk.green(`✓ Created directory: ${path.relative(process.cwd(), dir)}`));
    }

    await createTypesFile(targetDir);
    await createTokenSymbolFile(targetDir);
    await createWalletNameFile(targetDir);
    await createSystemNameFile(targetDir);
    await createUtilsFiles(targetDir);
    await createConstantsFile(targetDir);

    if (framework === "vite") await createUniversalIconComponentVite(targetDir);
    else await createUniversalIconComponent(targetDir);

    await createIndexFiles(targetDir);
}

async function createTypesFile(targetDir: string): Promise<void> {
    const typesContent = `export type ComponentProps = {
  className?: string;
  size?: number;
  width?: number;
  height?: number;
  alt?: string;
};

export type IconUrls = {
  lightMode: string;
  darkMode: string;
};

export { TokenSymbol } from './TokenSymbol';
export { WalletName } from './WalletName';
export { SystemName } from './SystemName';
`;

    const typesFile = path.join(targetDir, "types", "index.ts");
    await fs.writeFile(typesFile, typesContent);
    console.log(chalk.green(`✓ Created types file: ${path.relative(process.cwd(), typesFile)}`));
}

async function createTokenSymbolFile(targetDir: string): Promise<void> {
    const tokenSymbolContent = `// Token symbols enum
export enum TokenSymbol {
  // Example: BTC = "BTC"
}
`;
    const tokenSymbolFile = path.join(targetDir, "types", "TokenSymbol.ts");
    await fs.writeFile(tokenSymbolFile, tokenSymbolContent);
    console.log(chalk.green(`✓ Created TokenSymbol file: ${path.relative(process.cwd(), tokenSymbolFile)}`));
}

async function createWalletNameFile(targetDir: string): Promise<void> {
    const walletNameContent = `// Wallet names enum
export enum WalletName {
  // Example: MetaMask = "MetaMask"
}
`;
    const walletNameFile = path.join(targetDir, "types", "WalletName.ts");
    await fs.writeFile(walletNameFile, walletNameContent);
    console.log(chalk.green(`✓ Created WalletName file: ${path.relative(process.cwd(), walletNameFile)}`));
}

async function createSystemNameFile(targetDir: string): Promise<void> {
    const systemNameContent = `// System names enum
export enum SystemName {
  // Example: Ethereum = "Ethereum"
}
`;
    const systemNameFile = path.join(targetDir, "types", "SystemName.ts");
    await fs.writeFile(systemNameFile, systemNameContent);
    console.log(chalk.green(`✓ Created SystemName file: ${path.relative(process.cwd(), systemNameFile)}`));
}

async function createUtilsFiles(targetDir: string): Promise<void> {
    const utilsContent = `// Utility functions for theme handling
export function getImageSrc(lightMode: string, darkMode: string, mode: "light" | "dark"): string {
  return mode === "dark" ? darkMode : lightMode;
}
`;
    const utilsFile = path.join(targetDir, "utils", "theme.ts");
    await fs.writeFile(utilsFile, utilsContent);
    console.log(chalk.green(`✓ Created utils file: ${path.relative(process.cwd(), utilsFile)}`));
}

async function createConstantsFile(targetDir: string): Promise<void> {
    const constantsContent = `// Image path constants - auto-generated by CLI
export type ImagePaths = {
  lightMode: string;
  darkMode: string;
};

// Firebase Hosting URLs
export const baseImgUrl = 'https://crypto-images-4545f.web.app/images';
export const baseImgUrlToken = (nameToken: string) => baseImgUrl + '/token/' + nameToken + '.png';
export const baseImgUrlSystem = (nameSystem: string) => baseImgUrl + '/system/' + nameSystem + '.png';
export const baseImgUrlWallet = (nameWallet: string) => baseImgUrl + '/wallet/' + nameWallet + '.png';

// Icon name mapping - auto-generated by CLI
export const iconMap: Record<string, ImagePaths> = {
  // Token icons will be added here

  // Wallet icons will be added here

  // System icons will be added here
};

export function getIconPaths(name: string): ImagePaths | null {
  return iconMap[name] || null;
}
`;
    const constantsFile = path.join(targetDir, "constants", "imagePaths.ts");
    await fs.writeFile(constantsFile, constantsContent);
    console.log(chalk.green(`✓ Created constants file: ${path.relative(process.cwd(), constantsFile)}`));
}

async function createUniversalIconComponent(targetDir: string): Promise<void> {
    const componentContent = `"use client";
import Image, { ImageProps } from "next/image";
import { ComponentProps } from "./types";
import { getIconPaths } from "./constants/imagePaths";
import { useEffect, useState } from "react";

export type CryptoIconProps = Omit<ComponentProps, 'alt'> & 
  Omit<ImageProps, 'src' | 'width' | 'height' | 'alt'> & {
  name: string;
  mode?: "light" | "dark";
  fallback?: React.ReactNode;
  width?: number;
  height?: number;
  alt?: string;
  onError?: (error: Error) => void;
  onLoadingComplete?: (result: { naturalWidth: number; naturalHeight: number }) => void;
  placeholder?: "blur" | "empty" | undefined;
  blurDataURL?: string;
  loadingComponent?: React.ReactNode;
  errorComponent?: React.ReactNode;
};

export function CryptoIcon({
  name,
  mode,
  className = "",
  size = 24,
  width,
  height,
  alt,
  fallback,
  onError,
  onLoadingComplete,
  placeholder,
  blurDataURL,
  loadingComponent,
  errorComponent,
  ...imageProps
}: CryptoIconProps) {
  const [imageState, setImageState] = useState<'loading' | 'loaded' | 'error'>('loading');
  const [imageError, setImageError] = useState<Error | null>(null);
  const [mounted, setMounted] = useState(false);
  useEffect(() => setMounted(true), []);
  const iconPaths = getIconPaths(name);

  if (!iconPaths) {
    if (fallback) return <>{fallback}</>;
    const finalWidth = width ?? size;
    const finalHeight = height ?? size;
    return (
      <div
        className={"inline-flex items-center justify-center bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-300 text-xs font-medium rounded " + className}
        style={{ width: finalWidth, height: finalHeight }}
        title={alt || name}
      >
        {name.length > 4 ? name.substring(0, 4) : name}
      </div>
    );
  }

  const finalWidth = width ?? size;
  const finalHeight = height ?? size;

  // Avoid SSR/CSR mismatch when mode is not provided: wait until mounted
  if (!mode && !mounted) {
    if (loadingComponent) {
      return <>{loadingComponent}</>;
    }
    return (
      <div
        className={"inline-block rounded bg-gray-200 dark:bg-gray-700 " + className}
        style={{ width: finalWidth, height: finalHeight }}
        aria-hidden="true"
      />
    );
  }

  const effectiveMode = mode ?? "light";
  const imageSrc = effectiveMode === "dark" ? iconPaths.darkMode : iconPaths.lightMode;

  const handleError = () => {
    const error = new Error("Failed to load image: " + imageSrc);
    setImageError(error);
    setImageState('error');
    if (onError) onError(error);
  };

  const handleLoadingComplete = (result: { naturalWidth: number; naturalHeight: number }) => {
    setImageState('loaded');
    if (onLoadingComplete) onLoadingComplete(result);
  };

  if (imageState === 'loading' && loadingComponent) return <>{loadingComponent}</>;
  if (imageState === 'error') {
    if (errorComponent) return <>{errorComponent}</>;
    if (fallback) return <>{fallback}</>;
    return (
      <div
        className={"inline-flex items-center justify-center bg-red-100 dark:bg-red-900 text-red-600 dark:text-red-300 text-xs font-medium rounded border border-red-300 dark:border-red-700 " + className}
        style={{ width: finalWidth, height: finalHeight }}
        title={"Error loading " + (alt || name)}
      >
        ❌
      </div>
    );
  }

  return (
    <Image
      src={imageSrc}
      alt={alt || name}
      width={finalWidth}
      height={finalHeight}
      className={"transition-all duration-200 " + className}
      onError={handleError}
      onLoadingComplete={handleLoadingComplete}
      placeholder={placeholder}
      blurDataURL={blurDataURL}
      style={{ width: finalWidth + 'px!important', height: finalHeight + 'px!important' }}
      {...imageProps}
    />
  );
}
`;
    const componentFile = path.join(targetDir, "CryptoIcon.tsx");
    await fs.writeFile(componentFile, componentContent);
    console.log(chalk.green(`✓ Created universal icon component: ${path.relative(process.cwd(), componentFile)}`));
}

async function createUniversalIconComponentVite(targetDir: string): Promise<void> {
    const componentContent = `import React, { useState } from "react";
import { ComponentProps } from "./types";
import { getIconPaths } from "./constants/imagePaths";

export type CryptoIconProps = ComponentProps & {
  name: string;
  mode?: "light" | "dark";
  fallback?: React.ReactNode;
  alt?: string;
  loading?: "eager" | "lazy";
  referrerPolicy?: React.ImgHTMLAttributes<HTMLImageElement>["referrerPolicy"];
  decoding?: React.ImgHTMLAttributes<HTMLImageElement>["decoding"];
};

export function CryptoIcon({
  name,
  mode = "light",
  className = "",
  size = 24,
  width,
  height,
  alt,
  fallback,
  loading = "lazy",
  referrerPolicy,
  decoding = "async",
  ...imgProps
}: CryptoIconProps) {
  const [error, setError] = useState<Error | null>(null);
  const iconPaths = getIconPaths(name);

  const finalWidth = width ?? size;
  const finalHeight = height ?? size;

  if (!iconPaths) {
    if (fallback) return <>{fallback}</>;
    return (
      <div
        className={"inline-flex items-center justify-center bg-gray-200 text-gray-600 text-xs font-medium rounded " + className}
        style={{ width: finalWidth, height: finalHeight }}
        title={alt || name}
      >
        {name.length > 4 ? name.substring(0, 4) : name}
      </div>
    );
  }

  const src = mode === "dark" ? iconPaths.darkMode : iconPaths.lightMode;

  if (error) {
    if (fallback) return <>{fallback}</>;
    return (
      <div
        className={"inline-flex items-center justify-center bg-red-100 text-red-600 text-xs font-medium rounded border border-red-300 " + className}
        style={{ width: finalWidth, height: finalHeight }}
        title={"Error loading " + (alt || name)}
      >
        ❌
      </div>
    );
  }

  return (
    <img
      src={src}
      alt={alt || name}
      width={finalWidth}
      height={finalHeight}
      loading={loading}
      referrerPolicy={referrerPolicy}
      decoding={decoding}
      className={className}
      onError={() => setError(new Error("Failed to load image: " + src))}
      {...imgProps}
    />
  );
}
`;
    const componentFile = path.join(targetDir, "CryptoIcon.tsx");
    await fs.writeFile(componentFile, componentContent);
    console.log(chalk.green(`✓ Created Vite universal icon component: ${path.relative(process.cwd(), componentFile)}`));
}

async function createIndexFiles(targetDir: string): Promise<void> {
    const mainIndexContent = `export { CryptoIcon } from './CryptoIcon';
export * from './types';
export * from './constants/imagePaths';
`;
    const mainIndexFile = path.join(targetDir, "index.ts");
    await fs.writeFile(mainIndexFile, mainIndexContent);
    console.log(chalk.green(`✓ Created main index file: ${path.relative(process.cwd(), mainIndexFile)}`));
}
